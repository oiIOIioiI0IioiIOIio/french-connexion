import sys
import os
import wikipedia
import yaml
import frontmatter
from pathlib import Path
from dotenv import load_dotenv
import json
import re

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.utils.logger import setup_logger
from src.utils.git_handler import GitHandler
from src.utils.llm_client import MistralClient

# Configuration
load_dotenv()
logger = setup_logger()
git = GitHandler()
llm = MistralClient()

# Wikipedia en franÃ§ais
wikipedia.set_lang("fr")

# Chargement config
with open("config/config.yaml", "r", encoding="utf-8") as f:
    CONFIG = yaml.safe_load(f)


def search_people_on_wikipedia(query: str) -> list:
    """
    Recherche sur Wikipedia et extrait une liste de personnes Ã  partir d'une requÃªte
    (ex: "les prÃ©sidents de la 5e rÃ©publique", "les ministres actuels", etc.)
    """
    logger.info(f"ğŸ” Recherche Wikipedia pour : {query}")
    
    try:
        # Recherche Wikipedia
        search_results = wikipedia.search(query, results=5)
        
        if not search_results:
            logger.warning(f"Aucun rÃ©sultat trouvÃ© pour : {query}")
            return []
        
        # On prend le premier rÃ©sultat le plus pertinent
        page = wikipedia.page(search_results[0], auto_suggest=False)
        content = page.content
        
        logger.info(f"ğŸ“„ Page trouvÃ©e : {page.title}")
        
        # Extraction des noms via l'IA
        people_list = extract_people_from_text(content, query)
        
        return people_list
        
    except wikipedia.exceptions.PageError:
        logger.warning(f"Page Wikipedia non trouvÃ©e pour : {query}")
        return []
    except wikipedia.exceptions.DisambiguationError as e:
        logger.warning(f"Page ambiguÃ« pour '{query}'. Options : {e.options[:3]}")
        # On essaie la premiÃ¨re option
        try:
            page = wikipedia.page(e.options[0])
            content = page.content
            people_list = extract_people_from_text(content, query)
            return people_list
        except:
            return []
    except Exception as e:
        logger.error(f"Erreur lors de la recherche Wikipedia : {e}")
        return []


def extract_people_from_text(text: str, original_query: str) -> list:
    """
    Utilise Mistral pour extraire les noms des personnes mentionnÃ©es dans le texte Wikipedia
    en relation avec la requÃªte originale.
    """
    logger.info("ğŸ¤– Extraction des noms de personnes via Mistral...")
    
    # Tronquer le texte si trop long (limitÃ© Ã  ~8000 caractÃ¨res pour l'API)
    if len(text) > 8000:
        text = text[:8000]
    
    prompt = f"""
Tu es un assistant spÃ©cialisÃ© dans l'extraction de noms de personnes depuis des textes Wikipedia.

REQUÃŠTE ORIGINALE : "{original_query}"

Ã€ partir du texte Wikipedia ci-dessous, extrais une liste de noms complets de personnes 
qui correspondent Ã  la requÃªte.

RÃˆGLES :
- Retourne UNIQUEMENT les noms complets (PrÃ©nom Nom)
- N'inclus que des personnes rÃ©elles (pas de personnages fictifs)
- Maximum 20 personnes
- Format : liste JSON ["Nom1", "Nom2", ...]
- Si aucune personne trouvÃ©e, retourne []

TEXTE WIKIPEDIA :
{text}

Retourne la liste JSON des noms :
"""
    
    try:
        chat_response = llm.client.chat.complete(
            model=llm.model,
            messages=[
                {"role": "user", "content": prompt}
            ],
            response_format={"type": "json_object"}
        )
        
        if chat_response.choices and chat_response.choices[0].message:
            result = json.loads(chat_response.choices[0].message.content)
            
            # L'IA peut retourner {"names": [...]} ou directement une liste
            if isinstance(result, dict):
                people = result.get('names', result.get('personnes', result.get('list', [])))
            else:
                people = result
            
            logger.info(f"âœ… {len(people)} personnes extraites")
            return people
        
        return []
        
    except Exception as e:
        logger.error(f"Erreur lors de l'extraction de noms : {e}")
        return []


def get_person_info_from_wikipedia(person_name: str) -> dict:
    """
    RÃ©cupÃ¨re les informations d'une personne depuis Wikipedia.
    """
    logger.info(f"ğŸ“– RÃ©cupÃ©ration des infos pour : {person_name}")
    
    try:
        page = wikipedia.page(person_name, auto_suggest=True)
        summary = page.summary
        
        # Extraction des mÃ©tadonnÃ©es via Mistral
        schema = """
        {
          "birth_date": "Date de naissance (format YYYY-MM-DD ou texte)",
          "birth_place": "Lieu de naissance",
          "nationality": "NationalitÃ©",
          "occupation": "Profession principale",
          "education": "Formation ou diplÃ´me principal",
          "related_people": "Liste de noms de personnes proches (famille, collaborateurs, relations politiques) - format: liste de noms"
        }
        """
        
        extracted_data = llm.extract_yaml_data(summary, schema)
        extracted_data['wikipedia_url'] = page.url
        extracted_data['summary_text'] = summary[:500]  # RÃ©sumÃ© court
        
        return extracted_data
        
    except wikipedia.exceptions.PageError:
        logger.warning(f"âš ï¸  Page Wikipedia non trouvÃ©e pour : {person_name}")
        return None
    except wikipedia.exceptions.DisambiguationError as e:
        logger.warning(f"âš ï¸  AmbiguÃ¯tÃ© pour {person_name}. Tentative avec : {e.options[0]}")
        try:
            page = wikipedia.page(e.options[0])
            summary = page.summary
            schema = """
            {
              "birth_date": "Date de naissance",
              "birth_place": "Lieu de naissance",
              "nationality": "NationalitÃ©",
              "occupation": "Profession",
              "education": "Formation",
              "related_people": "Personnes proches (liste)"
            }
            """
            extracted_data = llm.extract_yaml_data(summary, schema)
            extracted_data['wikipedia_url'] = page.url
            extracted_data['summary_text'] = summary[:500]
            return extracted_data
        except:
            return None
    except Exception as e:
        logger.error(f"Erreur pour {person_name} : {e}")
        return None


def create_person_file(person_name: str, person_data: dict):
    """
    CrÃ©e un fichier Markdown pour une personne dans le dossier personnes/
    """
    personnes_folder = Path("personnes")
    personnes_folder.mkdir(exist_ok=True)
    
    # Nom de fichier safe
    safe_filename = re.sub(r'[^\w\s-]', '', person_name).strip()
    file_path = personnes_folder / f"{safe_filename}.md"
    
    # VÃ©rifier si la personne existe dÃ©jÃ 
    if file_path.exists():
        logger.info(f"â„¹ï¸  {person_name} existe dÃ©jÃ , ignorÃ©")
        return
    
    # Construction du contenu avec liens vers personnes proches
    related_people = person_data.get('related_people', [])
    if isinstance(related_people, str):
        # Si c'est une chaÃ®ne, on essaie de la parser
        related_people = [name.strip() for name in related_people.split(',')]
    
    # GÃ©nÃ©ration des liens wiki-style [[Personne]]
    relations_text = ""
    if related_people and len(related_people) > 0:
        relations_text = "\n\n## Relations\n\n"
        for related in related_people[:10]:  # Maximum 10 relations
            if related:
                relations_text += f"- [[{related}]]\n"
    
    summary_text = person_data.get('summary_text', '')
    wiki_url = person_data.get('wikipedia_url', '')
    
    content = f"""{summary_text}

{relations_text}

Source : [Wikipedia]({wiki_url})
"""
    
    # MÃ©tadonnÃ©es
    metadata = {
        'type': 'Personne',
        'birth_date': person_data.get('birth_date'),
        'birth_place': person_data.get('birth_place'),
        'nationality': person_data.get('nationality'),
        'occupation': person_data.get('occupation'),
        'education': person_data.get('education'),
        'website': None,
        'wikipedia_enriched': True,
        'keywords': [],
        'summary': ''
    }
    
    # CrÃ©ation du fichier
    post = frontmatter.Post(content, **metadata)
    
    with open(file_path, 'wb') as f:
        frontmatter.dump(post, f)
    
    logger.info(f"âœ… Fichier crÃ©Ã© : {file_path}")


def main():
    """
    Script principal interactif
    """
    print("\n" + "="*60)
    print("ğŸ” AJOUT DE PERSONNES VIA WIKIPEDIA")
    print("="*60)
    print("\nCe script permet d'ajouter des groupes de personnes")
    print("depuis Wikipedia en utilisant l'IA Mistral.\n")
    print("Exemples de requÃªtes :")
    print("  - les prÃ©sidents de la 5e rÃ©publique")
    print("  - les ministres de l'Ã©conomie franÃ§ais")
    print("  - les PDG du CAC 40")
    print("  - les membres du SiÃ¨cle")
    print("="*60)
    
    # Demande interactive
    query = input("\nğŸ‘¤ Qui voulez-vous chercher ? : ").strip()
    
    if not query:
        logger.error("âŒ RequÃªte vide, abandon")
        return
    
    logger.info(f"ğŸš€ Lancement de la recherche : '{query}'")
    
    # 1. Recherche des personnes sur Wikipedia
    people_list = search_people_on_wikipedia(query)
    
    if not people_list or len(people_list) == 0:
        logger.warning("âŒ Aucune personne trouvÃ©e pour cette requÃªte")
        return
    
    print(f"\nğŸ“‹ {len(people_list)} personnes trouvÃ©es :")
    for i, person in enumerate(people_list, 1):
        print(f"   {i}. {person}")
    
    # Confirmation
    confirm = input(f"\nâœ… Voulez-vous ajouter ces {len(people_list)} personnes ? (o/n) : ").strip().lower()
    
    if confirm != 'o':
        logger.info("âŒ Annulation")
        return
    
    # 2. Pour chaque personne : rÃ©cupÃ©rer infos + crÃ©er fichier
    added_count = 0
    for person_name in people_list:
        logger.info(f"\n{'='*50}")
        logger.info(f"Traitement de : {person_name}")
        
        person_data = get_person_info_from_wikipedia(person_name)
        
        if person_data:
            create_person_file(person_name, person_data)
            added_count += 1
        else:
            logger.warning(f"âš ï¸  Impossible de rÃ©cupÃ©rer les donnÃ©es pour {person_name}")
    
    # 3. Commit Git
    logger.info(f"\n{'='*50}")
    logger.info(f"âœ… {added_count} personnes ajoutÃ©es avec succÃ¨s")
    
    if added_count > 0:
        commit_msg = f"feat: ajout de {added_count} personnes via Wikipedia - {query}"
        git.commit_changes(commit_msg)
        logger.info("âœ… Changements committÃ©s")
    
    print("\n" + "="*60)
    print(f"ğŸ‰ TERMINÃ‰ ! {added_count} nouvelles fiches crÃ©Ã©es")
    print("="*60)


if __name__ == "__main__":
    main()
